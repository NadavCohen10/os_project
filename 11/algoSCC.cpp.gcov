        -:    0:Source:algoSCC.cpp
        -:    1:// ===== algoSCC.cpp =====
        -:    2:#include "algoSCC.h"
        -:    3:#include "graph.h"
        -:    4:#include <algorithm>
        -:    5:#include <stack>
        -:    6:#include <numeric>
        -:    7:
        -:    8:
        -:    9:
        -:   10:
        -:   11:// ---------- 2) SCC (Kosaraju) ----------
       13:   12:void algoSCC::dfs1(const vector<vector<int>> &m, int u, vector<int> &vis, vector<int> &order)
        -:   13:{
       13:   14:    vis[u] = 1;
       13:   15:    int n = (int)m.size();
       98:   16:    for (int v = 0; v < n; ++v)
       85:   17:        if (m[u][v] && !vis[v])
       11:   18:            dfs1(m, v, vis, order);
       13:   19:    order.push_back(u);
       13:   20:}
        -:   21:
       13:   22:void algoSCC::dfs2(const vector<vector<int>> &tr, int u, int cid, vector<int> &comp)
        -:   23:{
       13:   24:    comp[u] = cid;
       13:   25:    int n = (int)tr.size();
       98:   26:    for (int v = 0; v < n; ++v)
       85:   27:        if (tr[u][v] && comp[v] == -1)
       11:   28:            dfs2(tr, v, cid, comp);
       13:   29:}
        -:   30:
        2:   31:vector<int> algoSCC::scc(const Graph &g)
        -:   32:{
        2:   33:    const auto &m = g.getMatrix();
        2:   34:    int n = g.vertexCount();
        -:   35:    // If undirected, SCC == connected components; we can still run Kosaraju safely.
        4:   36:    vector<int> vis(n, 0), order;
        2:   37:    order.reserve(n);
       15:   38:    for (int i = 0; i < n; ++i)
       13:   39:        if (!vis[i])
        2:   40:            dfs1(m, i, vis, order);
        -:   41:    // transpose
        4:   42:    vector<vector<int>> tr(n, vector<int>(n, 0));
       15:   43:    for (int i = 0; i < n; ++i)
       98:   44:        for (int j = 0; j < n; ++j)
       85:   45:            if (m[i][j])
       50:   46:                tr[j][i] = 1;
        2:   47:    vector<int> comp(n, -1);
        2:   48:    int cid = 0;
       15:   49:    for (int i = n - 1; i >= 0; --i)
        -:   50:    {
       13:   51:        int v = order[i];
       13:   52:        if (comp[v] == -1)
        -:   53:        {
        2:   54:            dfs2(tr, v, cid, comp);
        2:   55:            cid++;
        -:   56:        }
        -:   57:    }
        4:   58:    return comp; // components are 0..cid-1
        2:   59:}
